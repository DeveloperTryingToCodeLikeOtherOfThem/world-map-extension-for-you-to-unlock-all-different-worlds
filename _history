{"entries":[{"timestamp":1756593905102,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1112,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":266,"length1":45,"diffs":[[1,"    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1756594497666,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":534,"length1":142,"diffs":[[1,""]]},{"start1":596,"length1":60,"diffs":[[1,"            this.worldMap.worldMap.setTileAt(col, row, index)\r\n"]]},{"start1":1072,"length1":108,"diffs":[[1,""]]},{"start1":1100,"length1":678,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":88,"diffs":[[1,"    \"name\": \"world map extension for you to unlock all different worlds\",\n"]]}]}]},{"timestamp":1756595096917,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":589,"length1":77,"diffs":[[1,"              this.worldMap.location = tiles.gretTileLocation(col, row)\r\n"]]},{"start1":676,"length1":248,"diffs":[[1,""]]},{"start1":1484,"length1":123,"diffs":[[1,"                if (!level === !cleared) {\r\n                    this.setTile(0, 0, 0)\r\n                    this.setWall(0, 0, false)\r\n"]]},{"start1":1641,"length1":94,"diffs":[[1,"                    this.addIfLevelIsClearedForTheWorldMap(level, cleared, col, row, index, on)\r\n"]]},{"start1":1754,"length1":2,"diffs":[[1,""]]},{"start1":2025,"length1":2,"diffs":[[1,""]]},{"start1":2033,"length1":49,"diffs":[[1,""]]}]}]},{"timestamp":1756595687174,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2267,"length1":659,"diffs":[[1,""]]},{"start1":2277,"length1":483,"diffs":[[1,"     export function setTileMapForLevel () {}\r\n"]]}]}]},{"timestamp":1756596290847,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2936,"length1":123,"diffs":[[1,"     export function setTileMapForLevel (loc: tiles.Location, tile: Image, on: boolean) {\r\n"]]}]}]},{"timestamp":1756596300009,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2008,"length1":109,"diffs":[[1,"         loaded (handler: () => void) {\r\n            tiles.addEventListener(tiles.TileMapEvent.Loaded, handler)\r\n         }\r\n\r\n         unloaded (handler: () => void) {\r\n             tiles.addEventListener(tiles.TileMapEvent.Unloaded, handler)\r\n         }\r\n\r\n"]]},{"start1":2801,"length1":14,"diffs":[[1,"\r\n"]]},{"start1":2936,"length1":129,"diffs":[[1,"     export function setTileMapForLevel (level: number, cleared: number, loc: tiles.Location, tile: Image, on: boolean) {\r\n"]]},{"start1":3348,"length1":111,"diffs":[[1,"         state().addIfLevelIsClearedForTheWorldMap(loc.x >> scale, loc.y >> scale, index, on)\r\n"]]}]}]},{"timestamp":1756597072165,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3335,"length1":8,"diffs":[[1,""]]}]}]},{"timestamp":1756597073532,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":257,"diffs":[[1," namespace worldmap {\r\n     interface World {\r\n         worldMap: tiles.TileMap\r\n         dataForMap: tiles.TileMapData\r\n         tile: tiles.Tile\r\n         location: tiles.Location\r\n         tiles: tiles.Tile[]\r\n     }\r\n"]]},{"start1":223,"length1":79,"diffs":[[1,"     export function state(): WorldMap {\r\n         return new WorldMap()\r\n     }\r\n"]]},{"start1":307,"length1":78,"diffs":[[1,"     export class WorldMap {\r\n         worldMap: World \r\n         sprite: Sprite \r\n         \r\n         constructor(map ?: World) {\r\n             this.worldMap = map\r\n             this.sprite = new Sprite(img`.`)\r\n         }\r\n"]]},{"start1":534,"length1":181,"diffs":[[1,"         getTileLocation (col: number, row: number) {\r\n"]]},{"start1":666,"length1":11,"diffs":[[1,"         }\r\n"]]},{"start1":680,"length1":238,"diffs":[[1,"         setAllTiles(index: number) {\r\n             this.worldMap.tiles.forEach(tile => {\r\n                 const loc = tiles.getTileLocation(tile.x, tile.y)\r\n                 this.setTile(loc.col, loc.row, index)\r\n             })\r\n         }\r\n"]]},{"start1":928,"length1":134,"diffs":[[1,"         setTile (col: number, row: number, index: number) {\r\n         this.worldMap.worldMap.setTileAt(col, row, index)\r\n         }\r\n"]]},{"start1":1064,"length1":129,"diffs":[[1,"         setWall (col: number, row: number, on: boolean) {\r\n             this.worldMap.worldMap.setWallAt(col, row, on)\r\n         }\r\n"]]},{"start1":1199,"length1":390,"diffs":[[1,"         addIfLevelIsClearedForTheWorldMap (level: number, cleared: number, col: number, row: number, index: number, on: boolean) {\r\n             if(level === cleared) {\r\n                 this.setTile(col, row, index)\r\n                 this.setWall(col, row, on)\r\n             } else  {\r\n                 this.setTile(0, 0, 0)\r\n                 this.setWall(0, 0, false)\r\n             }\r\n         }\r\n"]]},{"start1":1601,"length1":384,"diffs":[[1,"         removeIfLevelIsClearedForTheWorldMap(level: number, cleared: number, col: number, row: number, index: number, on: boolean) {\r\n             if (level !== cleared) {\r\n                 this.setTile(0, 0, 0)\r\n                 this.setWall(0, 0, false)\r\n             } else {\r\n                 this.addIfLevelIsClearedForTheWorldMap(level, cleared, col, row, index, on)\r\n             }\r\n"]]},{"start1":1994,"length1":11,"diffs":[[1,"         }\r\n"]]},{"start1":2008,"length1":334,"diffs":[[1,"         // adapted from  https://github.com/microsoft/pxt-common-packages/blob/master/libs/game/tilemap.ts\r\n         public getImageType(im: Image): number {\r\n             const tileset = this.worldMap.dataForMap.getTileset();\r\n             for (let i = 0; i < tileset.length; i++)\r\n                 if (tileset[i].equals(im)) return i;\r\n"]]},{"start1":2349,"length1":255,"diffs":[[1,"             // not found; append to the tileset if there are spots left.\r\n             const newIndex = tileset.length;\r\n             if (!this.isInvalidIndex(newIndex)) {\r\n                 tileset.push(im);\r\n                 return newIndex;\r\n             }\r\n"]]},{"start1":2612,"length1":35,"diffs":[[1,"             return -1;\r\n         }\r\n"]]},{"start1":2651,"length1":0,"diffs":[[1,"            \r\n         protected isInvalidIndex(index: number): boolean {\r\n             return index < 0 || index > 0xff;\r\n         }\r\n"]]},{"start1":2788,"length1":118,"diffs":[[1,"     }\r\n"]]},{"start1":2798,"length1":1109,"diffs":[[1,"     export function setTileMapForLevel (level: number, cleared: number, loc: tiles.Location, tile: Image, on: boolean): void {\r\n         if (!loc || !tile || !state().worldMap.dataForMap) return null;\r\n         const scale = state().worldMap.dataForMap.scale;\r\n         const index = state().worldMap.worldMap.getImageType(tile);\r\n         state().worldMap.worldMap.setTileAt(loc.x >> scale, loc.y >> scale, index);\r\n         state().addIfLevelIsClearedForTheWorldMap(level, cleared, loc.x >> scale, loc.y >> scale, index, on)\r\n     }\r\n     s\r\n }\r\n "]]}]}]},{"timestamp":1756597673167,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":259,"length1":26,"diffs":[[1,""]]},{"start1":300,"length1":69,"diffs":[[1,"        return new WorldMap()\r\n"]]},{"start1":340,"length1":2,"diffs":[[1,""]]},{"start1":420,"length1":42,"diffs":[[1,"        constructor(map?: World) {\r\n"]]},{"start1":535,"length1":40,"diffs":[[1,""]]},{"start1":1764,"length1":90,"diffs":[[1,"                this.setTile(0, 0, 0)\r\n                this.setWall(0, 0, false)\r\n"]]},{"start1":2752,"length1":464,"diffs":[[1,"    //% blockId=\"set_tilemap_for_level\" block=\"set tilemap for level %level $cleared $loc $tile $on\"\r\n    export function setTileMapForLevel(level: number, cleared: number, loc: tiles.Location, tile: Image, on: boolean): void {\r\n"]]},{"start1":3345,"length1":253,"diffs":[[1,"\r\n"]]}]}]},{"timestamp":1756598271739,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":161,"length1":27,"diffs":[[1,"        tile: tiles.Tile\r\n"]]},{"start1":486,"length1":57,"diffs":[[1,"        constructor(map?: World, tile) {\r\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":248,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1756593905101,"editorVersion":"2.0.56","text":{"main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"world map extension for you to unlock all different worlds\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1756595749797,"editorVersion":"2.0.56","text":{"main.ts":" namespace worldmap {\r\n     interface World {\r\n         worldMap: tiles.TileMap\r\n         dataForMap: tiles.TileMapData\r\n         tile: tiles.Tile\r\n         location: tiles.Location\r\n         tiles: tiles.Tile[]\r\n     }\r\n\r\n     export function state(): WorldMap {\r\n         return new WorldMap()\r\n     }\r\n\r\n     export class WorldMap {\r\n         worldMap: World \r\n         sprite: Sprite \r\n         \r\n         constructor(map ?: World) {\r\n             this.worldMap = map\r\n             this.sprite = new Sprite(img`.`)\r\n         }\r\n\r\n         getTileLocation (col: number, row: number) {\r\n            return this.worldMap.location = tiles.getTileLocation(col, row)\r\n         }\r\n\r\n         setAllTiles(index: number) {\r\n             this.worldMap.tiles.forEach(tile => {\r\n                 const loc = tiles.getTileLocation(tile.x, tile.y)\r\n                 this.setTile(loc.col, loc.row, index)\r\n             })\r\n         }\r\n\r\n\r\n         setTile (col: number, row: number, index: number) {\r\n         this.worldMap.worldMap.setTileAt(col, row, index)\r\n         }\r\n\r\n         setWall (col: number, row: number, on: boolean) {\r\n             this.worldMap.worldMap.setWallAt(col, row, on)\r\n         }\r\n\r\n         addIfLevelIsClearedForTheWorldMap (level: number, cleared: number, col: number, row: number, index: number, on: boolean) {\r\n             if(level === cleared) {\r\n                 this.setTile(col, row, index)\r\n                 this.setWall(col, row, on)\r\n             } else  {\r\n                 this.setTile(0, 0, 0)\r\n                 this.setWall(0, 0, false)\r\n             }\r\n         }\r\n\r\n         removeIfLevelIsClearedForTheWorldMap(level: number, cleared: number, col: number, row: number, index: number, on: boolean) {\r\n             if (level !== cleared) {\r\n                 this.setTile(0, 0, 0)\r\n                 this.setWall(0, 0, false)\r\n             } else {\r\n                 this.addIfLevelIsClearedForTheWorldMap(level, cleared, col, row, index, on)\r\n             }\r\n\r\n         }\r\n\r\n         loaded (handler: () => void) {\r\n            tiles.addEventListener(tiles.TileMapEvent.Loaded, handler)\r\n         }\r\n\r\n         unloaded (handler: () => void) {\r\n             tiles.addEventListener(tiles.TileMapEvent.Unloaded, handler)\r\n         }\r\n\r\n     }\r\n\r\n     export function setTileMapForLevel () {}\r\n }\r\n ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"world map extension for you to unlock all different worlds with utilites\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1756597556526,"editorVersion":"2.0.56","text":{"main.ts":"//% block=\"world map\" groups=['world map']\r\nnamespace worldmap {\r\n    interface World {\r\n        worldMap: tiles.TileMap\r\n        dataForMap: tiles.TileMapData\r\n        tile: tiles.Tile\r\n        location: tiles.Location\r\n        tiles: tiles.Tile[]\r\n    }\r\n\r\n    export function state(): WorldMap {\r\n        return new WorldMap()\r\n    }\r\n\r\n    export class WorldMap {\r\n        worldMap: World\r\n        sprite: Sprite\r\n\r\n        constructor(map?: World) {\r\n            this.worldMap = map\r\n            this.sprite = new Sprite(img`.`)\r\n        }\r\n\r\n        getTileLocation(col: number, row: number) {\r\n            return this.worldMap.location = tiles.getTileLocation(col, row)\r\n        }\r\n\r\n        setAllTiles(index: number) {\r\n            this.worldMap.tiles.forEach(tile => {\r\n                const loc = tiles.getTileLocation(tile.x, tile.y)\r\n                this.setTile(loc.col, loc.row, index)\r\n            })\r\n        }\r\n\r\n\r\n        setTile(col: number, row: number, index: number) {\r\n            this.worldMap.worldMap.setTileAt(col, row, index)\r\n        }\r\n\r\n        setWall(col: number, row: number, on: boolean) {\r\n            this.worldMap.worldMap.setWallAt(col, row, on)\r\n        }\r\n\r\n        addIfLevelIsClearedForTheWorldMap(level: number, cleared: number, col: number, row: number, index: number, on: boolean) {\r\n            if (level === cleared) {\r\n                this.setTile(col, row, index)\r\n                this.setWall(col, row, on)\r\n            } else {\r\n                this.setTile(0, 0, 0)\r\n                this.setWall(0, 0, false)\r\n            }\r\n        }\r\n\r\n        removeIfLevelIsClearedForTheWorldMap(level: number, cleared: number, col: number, row: number, index: number, on: boolean) {\r\n            if (level !== cleared) {\r\n                this.setTile(0, 0, 0)\r\n                this.setWall(0, 0, false)\r\n            } else {\r\n                this.addIfLevelIsClearedForTheWorldMap(level, cleared, col, row, index, on)\r\n            }\r\n\r\n        }\r\n\r\n        // adapted from  https://github.com/microsoft/pxt-common-packages/blob/master/libs/game/tilemap.ts\r\n        public getImageType(im: Image): number {\r\n            const tileset = this.worldMap.dataForMap.getTileset();\r\n            for (let i = 0; i < tileset.length; i++)\r\n                if (tileset[i].equals(im)) return i;\r\n\r\n            // not found; append to the tileset if there are spots left.\r\n            const newIndex = tileset.length;\r\n            if (!this.isInvalidIndex(newIndex)) {\r\n                tileset.push(im);\r\n                return newIndex;\r\n            }\r\n\r\n            return -1;\r\n        }\r\n\r\n\r\n        protected isInvalidIndex(index: number): boolean {\r\n            return index < 0 || index > 0xff;\r\n        }\r\n\r\n    }\r\n\r\n    export function setTileMapForLevel(level: number, cleared: number, loc: tiles.Location, tile: Image, on: boolean): void {\r\n        if (!loc || !tile || !state().worldMap.dataForMap) return null;\r\n        const scale = state().worldMap.dataForMap.scale;\r\n        const index = state().getImageType(tile);\r\n        state().setTile(loc.x >> scale, loc.y >> scale, index);\r\n        state().addIfLevelIsClearedForTheWorldMap(level, cleared, loc.x >> scale, loc.y >> scale, index, on)\r\n    }\r\n\r\n    export function removeTileMapForLevel(level: number, cleared: number, loc: tiles.Location, tile: Image, on: boolean): void {\r\n        if (!loc || !tile || !state().worldMap.dataForMap) return null;\r\n        const scale = state().worldMap.dataForMap.scale;\r\n        const index = state().getImageType(tile);\r\n        state().setTile(loc.x >> scale, loc.y >> scale, index);\r\n        state().removeIfLevelIsClearedForTheWorldMap(level, cleared, loc.x >> scale, loc.y >> scale, index, on)\r\n    }\r\n}\r\n\r\n","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"world map extension for you to unlock all different worlds with utilites\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[],"lastSaveTime":1756598526661}